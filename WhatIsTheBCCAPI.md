# What is the BCCAPI? #

Simply put the BCCAPI (Bit Coin Client API) allows you to create a light-weight secure Bitcoin client in Java. The BCCAPI connects to a server that holds the block chain, and which tracks the client’s wallet balance. The server only has knowledge of the clients public keys, and is in no position to spend funds owned by the client’s wallet.

Features for clients based on the BCCAPI:
  * Bandwidth. The client only transmits or receives data when it:
    * Logs in
    * Gets its balance
    * Adds public keys to its wallet
    * Sends bitcoins

  * Security
    * Only the client holds the private keys of the wallet.
    * The server only holds the corresponding public keys, and cannot spend funds from the wallet.
    * Managing private keys depends on the client side implementation. The BCCAPI provides an open source JAVA library that provides the client with:
      * functions for deriving all keys deterministically from a strong seed. This reduces the amount of sensitive data that the client side needs to handle to 32 bytes.
      * functions for generating the strong seeds from a passphrase and salt of arbitrary length. Seeds are generated by several rounds of scrypt for keystretching. Scrypt is designed to be far more secure against hardware brute-force attacks than alternative functions such as PBKDF2 or bcrypt. (http://www.tarsnap.com/scrypt/scrypt.pdf) This process takes a significant amount of time on small devices, but could be a one-time process, part of client initialization.
      * functions for encrypting the seed using a password of arbitrary length. If someone obtains a copy of the encrypted seed they will have to bruteforce it before the theft is discovered and the funds moved elsewhere.
    * SimpleClient is an open source example of a client that uses these functions to achieve a fully functional, secure, and light weight Bitcoin client. Other clients may choose to use randomly generated seeds rather than seeds generated from passphrases, and combine this with a means of backing up the seed. This is entirely up to the client.
    * All client-server communication is secured using HTTPS.

  * Logging In
    * The client has a private account key which can be deterministically derived just like the wallet private keys. When logging in to the server the client presents its public account key and obtains a random challenge. The client hashes the challenge and signs it using its private account key. The signed challenge is returned to the server along with the public account key. On first login a new account is created, which is associated with the public account key of the client. The only thing required to create an account is a public key, and the ability to make a signature on a random challenge using the corresponding private key. No other personal information or email addresses required.

  * Sending Coins
    * When sending coins the following process is used:
      1. The client requests a Send Coin Form from the server for a number of Bitcoins and a receiving address.
      1. The server collects funds from the client’s wallet’s unspent transactions and creates an unsigned transaction where any change is sent back to one of the client’s addresses. The transaction along with any transaction outputs funding it are inserted in a Send Coin Form which is sent to the client.
      1. The client verifies that the input funds, output funds, and receivers match what it requested.
      1. The client signs the transaction and sends it to the server.
      1. The server verifies the signature on the transaction and broadcasts it on the bitcoin network.

  * Backup
    * If the passphrase + salt approach is used for generating the seed there is no need to backup anything on the client. If the encrypted seed file is lost it can be recreated from the initial passphrase and salt on a different device.
    * If a randomly generated seed is used along with deterministic key generation only the 32 byte seed needs to get backed up once and for all. The seed can optionally be encrypted before leaving the client.

The BCCAPI provides all of the above as well-documented easy to read source code, and is a perfect match if you want to write a light-weight secure Andriod app for sending and receiving Bitcoins.

## The Server Side ##
The BCCAPI server is running at Rackspace and can handle many simultaneous accounts. For each account the server holds a public key which is associated with all the public keys added to the account's wallet. The server is connected to the Bitcoin network and keeps track of the block chain, and does all the bookkeeping necessary to keep wallets up to date.

### FAQ ###

  * Q: Does the server have my wallet?
  * A: The BCCAPI basically splits your wallet into two.
    1. A public part which is on the server side, which allows the server to keep track of the transaction inputs and outputs of your wallet. For this purpose it needs to know the public keys of your wallet.
    1. A private part which is on the client side. The client part is the one in control of the private keys, which allows you to sign transactions and spend bitcoins.

  * Q: Can the server spend my bitcoins?
  * A: No. The server is in no position to sign transactions associated with your wallet.

  * Q: What evilness can the server do?
  * A: While the server cannot spend your bitcoins, there is some evilness that the server can do:
    1. The server can lie about the wallet balance, making you believe that it is higher or lower than what it really is.
    1. The server can make you believe that you have sent some bitcoins, while it just did not forward the transaction to the network.
    1. The server can try to make you sign a transaction that has input which is already spent. In this case the transaction will be invalid and rejected by the network. You will not loose any bitcoins.
    1. The server can try to make you sign a transaction which sends money to someone else than what you asked for. The client always validates that a transaction is for the intended recipients before signing, so in this case the client will reject the transaction.
    1. The server can go offline and never come back.
> In all of the above scenarios you would be unhappy and wanting to evacuate all of your bitcoins to somewhere else. Since the server has no control over your bitcoins this is not a problem. All the private keys are deterministically generated from your passphrase and salt. You simply run a tool that generates a wallet.dat file for the ordinary bitcoin client.

  * Q: Where can I get this tool?
  * A: It is part of the bccapi.jar. Look for com.bccapi.tool.WalletExporter.java ,it prints out all your private keys in plain text. Next thing is to import them into a wallet.dat file. This can be done using [pywallet](https://github.com/joric/pywallet). A turnkey tool is in progress.

  * Q: Are there limits on the number of addresses I can use?
  * A: For now the number of addresses you can associate with one account is limited to 10. This is to limit the strain on the server side.

  * Q: What does this service cost for me?
  * A: Nothing. Running and maintaining the server side does costs money, but the hope is that donations can keep the bills from piling. Going forward we may add the option of paying a small fee for getting connected to a priority server, which provides faster service.

  * Q: How can determistic wallets be secure?
  * A: See the wiki [Security And Deterministic Wallets](SecurityAndDeterministicWallets.md)
## Donations Accepted ##
If you want to support the BCCAPI please send donations to:
**143SikKpjzwhBy5Z7Qg5knu5nKXWExSqQi**

Or simply use this QR code and donate using BitcoinSpinner

![http://qrcode.kaywa.com/img.php?s=5&d=143SikKpjzwhBy5Z7Qg5knu5nKXWExSqQi&nonsense=qr-code.png](http://qrcode.kaywa.com/img.php?s=5&d=143SikKpjzwhBy5Z7Qg5knu5nKXWExSqQi&nonsense=qr-code.png)